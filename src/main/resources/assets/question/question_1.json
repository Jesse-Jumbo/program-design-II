[
  {
    "question": "Q: 若一個 Java 類別使用一個介面(Interface)，它必須使用以下那一個關鍵字？\nA extends\nB inherits\nC super\nD implements",
    "answer": "D",
    "explanation": "在 Java 中，當一個類別要使用一個介面時，必須使用關鍵字 implements。這是因為介面定義了一組方法，任何實作該介面的類別都必須實作這些方法。其他選項如 extends 用於類別繼承，inherits 和 super 則與類別繼承相關，但與介面無關。"
  },
  {
    "question": "Q: 下列何者可比較兩個 Java 程式物件的內容是否一樣？\nA =\nB ==\nC 定義 equals method 比較內容\nD 定義 equals method 比較變數名稱是否相同",
    "answer": "C",
    "explanation": "在 Java 中，要比較兩個物件的內容是否相同，應該使用 equals 方法，而不是 = 或 ==。選項 A 和 B 都是錯誤的，因為 = 是賦值運算符，而 == 比較的是物件的記憶體地址，即兩個物件是否引用同一個實例。選項 D 是錯誤的，因為 equals 方法應該用來比較物件的內容，而不是變數名稱。"
  },
  {
    "question": "Q: 下列何者不是 Java 語言的關鍵字(Keyword)？\nA super\nB this\nC then\nD finally",
    "answer": "C",
    "explanation": "在 Java 語言中，super、this 和 finally 都是關鍵字。其中：\nsuper 用於呼叫父類別的建構子或方法。\nthis 用於引用當前物件的實例。\nfinally 用於在 try-catch 區塊中定義一定會執行的程式碼段。\n然而，then 並不是 Java 語言的關鍵字，因此選項 C 是正確答案。"
  },
  {
    "question": "Q: 若一 Java 程式的 Recursive Method 沒有基本案例(Base Case)，下述何者正確？\nA 程式無法停止。\nB 有可能編譯錯誤\nC 程式能編譯，但將產生不正確結果\nD 產生MissingBase CaseException",
    "answer": "A",
    "explanation": "如果一個 Java 程式的遞迴方法沒有基本案例（Base Case），遞迴方法將無法停止，因為它會不斷地呼叫自身，導致無限遞迴。這最終會導致堆疊溢出錯誤（StackOverflowError）。選項 B 是錯誤的，因為編譯器無法檢測遞迴方法是否有基本案例。選項 C 也是不完全正確，因為程式會陷入無限遞迴，而非僅僅產生不正確結果。選項 D 是錯誤的，因為沒有名為 MissingBase CaseException 的例外。"
  },
  {
    "question": "Q: 有關物件導向程式設計(Object-oriented Programming)之敘述，下列何者錯誤？\nA 物件可以被不同程式使用\nB 使用物件時必需知道物件的資料結構\nC 物件導向程式設計也是一種結構化設計\nD 物件含資料與方法",
    "answer": "B",
    "explanation": "物件導向程式設計（OOP）強調封裝（Encapsulation），這意味著在使用物件時，不需要知道物件的內部資料結構，只需要知道如何調用它的公開方法。這使得程式設計更加模組化和易於維護。"
  },
  {
    "question": "Q: 有關物件導向語言繼承的敘述，以下何者正確？\nA C++有多重介面繼承\nB Java 有多重類別繼承\nC C語言只有單一類別繼承\nD Java 有多重介面繼承",
    "answer": "D",
    "explanation": "在物件導向語言中，繼承是一種重要的特性。選項 D 是正確的，因為 Java 支持多重介面繼承，這意味著一個類別可以實作多個介面。選項 A 是不完全正確的，因為 C++ 支援多重繼承，不僅限於介面，還包括類別。選項 B 是錯誤的，因為 Java 不支持多重類別繼承，但它通過介面提供類似的功能。選項 C 也是錯誤的，因為 C 語言不是物件導向語言，沒有類別和繼承的概念。"
  },
  {
    "question": "Q: 下列哪個 Java 語言指令敘述，其修飾子的使用是合法的？\nA abstract double d ;\nB class MyClass extends WindowAdapter implements WindowListener { /** **/}\nC public transient void b Method() { /** **/}\nD friend class Base { /** **/}",
    "answer": "B",
    "explanation": "在 Java 中，A: abstract double d; 中的空格錯誤且不合法，且 abstract 不能與變數一起使用。B: class MyClass extends WindowAdapter implements WindowListener { /** **/} 是合法的，因為類別可以繼承另一個類別並實作多個介面。C: public transient void b Method() { /** **/} 中的 transient 關鍵字只能用於變數，不能用於方法，這是不合法的。D: friend 關鍵字在 Java 中不存在，它是 C++ 的關鍵字，因此這是不合法的。"
  },
  {
    "question": "Q: 一般而言，主程式呼叫副程式所傳遞的參數以及副程式未來欲返回主程式之位址，會透過何種資料結構傳遞？\nA 堆疊（stack）\nB 佇列（queue）\nC 陣列（array）\nD 樹（tree）",
    "answer": "A",
    "explanation": "一般而言，主程式呼叫副程式時所傳遞的參數以及副程式未來欲返回主程式的位址，會透過堆疊（stack）這種資料結構來傳遞。這是因為堆疊具有後進先出（LIFO）的特性，非常適合用來管理函數呼叫和返回過程中的資訊。當一個副程式被呼叫時，會將當前的返回位址和參數推入堆疊；當副程式執行完畢後，會從堆疊中彈出這些資訊以返回主程式。"
  },
  {
    "question": "Q: 使用二元搜尋法（Binary Search）在一個已經按照數字大小排序的陣列上搜尋數字 x 時，其搜尋過程中第一個比對的數目是 50，第二個比對的數字是 15，則下列何者正確？\nA x < 50\nB x >= 50\nC x <= 15\nD 15 <= x < 50",
    "answer": "D",
    "explanation": "在二元搜尋法中，每次比對的數字是中間位置的數字。如果第一個比對的數字是 50，且第二個比對的數字是 15，這說明 x 小於 50，因此搜尋的範圍縮小到 50 以下的部分。接著，比對中間位置的數字 15，這意味著 x 可能在範圍 15 和 50 之間。"
  },
  {
    "question": "Q: 下列有關 UML 的敘述，何者有誤？\nA UML 是一種以物件導向為基礎的圖形化建模語言\nB UML 以圖形敘述、展示，記載軟體系統的架構與設計\nC UML 不能用來建立商業模式或是描述其他類別的系統\nD UML 的英文全名是 Unified Modeling Language",
    "answer": "C",
    "explanation": "UML 不僅能用來建立軟體系統的模型，還能用來建立商業模式或是描述其他類別的系統，如業務流程等。"
  },
  {
    "question": "Q: 下列何種程式語言於編譯程式產生中間碼後，可移植到不同的作業平台(如 Windows、Unix)？\nA Pascal\nB C++\nC Cobol\nD Java",
    "answer": "D",
    "explanation": "Java 是一種物件導向程式設計語言，它在編譯過程中會產生中間碼（字節碼Bytecode）。這些字節碼可以在任何安裝了 Java 虛擬機（JVM，Java Virtual Machine）的作業平台上執行，實現了跨平台的可移植性。其他選項如 Pascal、C++ 和 Cobol 都不具有這種特性。"
  },
  {
    "question": "Q: 迴圈的跳離分為 break 與 continue 兩類，請問下面哪個選項是正確的？\nA break 讓程式強迫跳離迴圈\nB break 可以強迫程式跳到迴圈起頭\nC continue 讓程式強迫跳離迴圈\nD continue 無法強迫程式跳到迴圈起頭",
    "answer": "A",
    "explanation": "A：正確，break 用於強制跳出迴圈，終止當前的迴圈執行。B：錯誤，break 不是用來跳到迴圈起頭，而是用來終止迴圈。C：錯誤，continue 是用來跳過當前迴圈的剩餘部分，開始下一次迴圈迭代，而不是跳離迴圈。D：錯誤，continue 的確是用來跳過當前迴圈的剩餘部分並開始下一次迴圈迭代，相當於跳到迴圈的起頭。"
  },
  {
    "question": "Q: 程式的結構包含：循序式結構、選擇性結構、重複性結構。請問下列哪個不屬於選擇性結構( selection structure )？\nA if\nB for\nC if-else\nD switch",
    "answer": "B",
    "explanation": "A：if 屬於選擇性結構，用於根據條件執行特定的程式碼。\nB：for 屬於重複性結構（迴圈結構），用於重複執行一段程式碼。\nC：if-else 屬於選擇性結構，用於根據條件選擇執行不同的程式碼。\nD：switch 屬於選擇性結構，用於根據不同的條件選擇執行不同的程式碼。"
  },
  {
    "question": "Q: 執行緒( Thread ) 的處理，必須寫在下列哪個方法中？\nA notify()\nB start()\nC run()\nD join()",
    "answer": "C",
    "explanation": "A：notify() 用於喚醒等待在該物件的監視器上的某個執行緒，與執行緒的處理方法無關。\nB：start() 用於啟動一個新的執行緒，並讓它進入可執行狀態，但執行緒的處理方法不寫在這裡。\nC：run() 是執行緒的處理方法，所有的執行緒操作都應該寫在這個方法中。\nD：join() 用於讓一個執行緒等待另一個執行緒結束，與執行緒的處理方法無關。"
  },
  {
    "question": "Q: 下列何者可用於區分超載方法( Overloading method )？\nA 傳回值的資料型態\nB 方法的參數列\nC 方法的修飾子( modifier )\nD 方法的名稱",
    "answer": "B",
    "explanation": "A：傳回值的資料型態不能用於區分超載方法，因為編譯器無法僅根據傳回值的型態來判斷應該調用哪個方法。\nB：方法的參數列是區分超載方法的關鍵，超載方法必須有不同的參數數量或參數型態。\nC：方法的修飾子（如 public、private、static 等）不能用於區分超載方法。\nD：方法的名稱相同是超載方法的特徵之一，不同名稱的兩個方法不構成超載。"
  },
  {
    "question": "Q: 下列關於抽象類別( abstract class ) 的描述，何者為真？\nA 類別可繼承一個以上的抽象類別\nB 類別可用 “implements” 實作抽象類別\nC 抽象類別內的所有方法( method )，都必須設為 abstract\nD 抽象類別不能直接產生物件",
    "answer": "D",
    "explanation": "A：錯誤，在 Java 中，類別只能繼承一個抽象類別，不能繼承多個。\nB：錯誤，類別不能用 implements 關鍵字實作抽象類別，implements 用於實作介面（interface）。抽象類別需要用 extends 關鍵字繼承。\nC：錯誤，抽象類別內不需要所有的方法都設為 abstract，抽象類別可以包含具體的方法（concrete methods）。\nD：正確，抽象類別不能直接產生物件，必須透過子類別來實作並產生物件。"
  },
  {
    "question": "Q: 關於例外處理，下列哪個項目錯誤？\nA 程式中拋出例外，要用關鍵字 throw\nB method 拋出例外，要用關鍵字 throw\nC 利用 try-catch-finally 捕捉例外時，允許使用多個 catch\nD 如果程式沒有撰寫例外處理，Java 預設處理會先拋出例外、再停止程式執行",
    "answer": "B",
    "explanation": "A：正確，在程式中拋出例外時使用關鍵字 throw。\nB：錯誤，method 拋出例外應使用關鍵字 throws，而不是 throw。\nC：正確，使用 try-catch-finally 捕捉例外時，允許使用多個 catch 區塊來捕捉不同類型的例外。\nD：正確，如果程式沒有撰寫例外處理，Java 的預設處理會先拋出例外，然後停止程式執行。"
  },
  {
    "question": "Q: 下列哪一個類別可以處理二進位檔案( binary file ) 的資料？\nA Reader\nB FileReader\nC BufferedReader\nD FileInputStream",
    "answer": "D",
    "explanation": "A：Reader 是處理字符流（character streams）的抽象類別，不直接處理二進位檔案。\nB：FileReader 繼承自 Reader，用於讀取字符檔案，也不能直接處理二進位檔案。\nC：BufferedReader 繼承自 Reader，用於高效地讀取字符檔案，不能直接處理二進位檔案。\nD：FileInputStream 用於讀取二進位檔案（binary files）的資料，適合處理二進位資料。"
  },
  {
    "question": "Q: 在類別中的成員( field 及 method )，若只提供其子類別( sub-class ) 存取，應將成員宣告為？\nA final\nB public\nC protected\nD private",
    "answer": "C",
    "explanation": "A：final 用於表示該成員不能被修改（對變數來說）或不能被覆蓋（對方法來說），與存取權限無關。\nB：public 表示成員可以被所有類別存取，並不限於子類別。\nC：protected 表示成員只能被同一個包中的類別以及該類別的子類別存取。\nD：private 表示成員只能被該類別本身存取，不能被子類別或其他類別存取。"
  },
  {
    "question": "Q: 所有 Java 的類別都是繼承自什麼類別？\nA Object\nB Class\nC Number\nD String",
    "answer": "A",
    "explanation": "在 Java 中，所有的類別都繼承自 java.lang.Object 類別。Object 是 Java 類別層次結構的根類別，這意味著每個 Java 類別都直接或間接地繼承自 Object。\nA：正確，所有 Java 的類別都是繼承自 Object。\nB：錯誤，Class 是用來表示類別結構的類別，但不是所有類別的超類別。\nC：錯誤，Number 是一個抽象類別，用於表示數值型類別的超類別，但不是所有類別的超類別。\nD：錯誤，String 是表示字串的類別，但不是所有類別的超類別。"
  }
]
